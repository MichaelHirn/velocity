<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/core.js - Velocity</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://velocity.meteor.com/images/velocity_logo.svg" title="Velocity"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.6.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Collections.html">Collections</a></li>
                                <li><a href="../classes/Meteor.methods.html">Meteor.methods</a></li>
                                <li><a href="../classes/Velocity.html">Velocity</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/Velocity.html">Velocity</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/core.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*jshint -W117, -W030, -W016, -W084 */
/* global
 DEBUG:true
 */

DEBUG = !!process.env.VELOCITY_DEBUG;
CONTINUOUS_INTEGRATION = process.env.VELOCITY_CI;

/**
 * @module Velocity
 * @class Velocity
 */
(function () {
  &#x27;use strict&#x27;;

//////////////////////////////////////////////////////////////////////
// Init
//

  if (process.env.NODE_ENV !== &#x27;development&#x27; ||
    process.env.VELOCITY === &#x27;0&#x27; ||
    process.env.IS_MIRROR) {
    DEBUG &amp;&amp; console.log(&#x27;[velocity] &#x27; + (process.env.IS_MIRROR ? &#x27;Mirror detected - &#x27; : &#x27;&#x27;) + &#x27;Not adding velocity core&#x27;);
    return;
  }
  DEBUG &amp;&amp; console.log(&#x27;[velocity] adding velocity core&#x27;);
  CONTINUOUS_INTEGRATION &amp;&amp; console.log(&#x27;[velocity] is in continuous integration mode&#x27;);

  var _ = Npm.require(&#x27;lodash&#x27;),
      files = VelocityMeteorInternals.files,
      fs = Npm.require(&#x27;fs-extra&#x27;),
      mkdirp = Meteor.wrapAsync(fs.mkdirp, fs),
      _config = {},
      _watcher,
      _velocityStarted = false,
      _velocityStartupFunctions = [],
      FIXTURE_REG_EXP = new RegExp(&#x27;-fixture.(js|coffee)$&#x27;);


  Meteor.startup(function initializeVelocity () {
    DEBUG &amp;&amp; console.log(&#x27;[velocity] Server startup&#x27;);
    DEBUG &amp;&amp; console.log(&#x27;[velocity] app dir&#x27;, Velocity.getAppPath());
    DEBUG &amp;&amp; console.log(&#x27;[velocity] config =&#x27;, JSON.stringify(_config, null, 2));

    //kick-off everything
    _reset(_config);

    if (!process.env.IS_MIRROR) {
      _initFileWatcher(_config, _triggerVelocityStartupFunctions);
    }

    _launchContinuousIntegration(_config);

  });

//////////////////////////////////////////////////////////////////////
// Public Methods
//

  _.extend(Velocity, {

    /**
     * Run code when Velocity is started. Velocity is considered started when the file watcher has
     * completed the scan of the  file system
     *
     * @method startup
     * @return {function} A function to run on startup
     */
    startup: function (func) {
      if (_velocityStarted) {
        DEBUG &amp;&amp; console.log(&#x27;[velocity] Velocity already started. Immediately calling func&#x27;);
        func();
      } else {
        DEBUG &amp;&amp; console.log(&#x27;[velocity] Velocity not started. Queueing func&#x27;);
        _velocityStartupFunctions.push(func);
      }
    },

    /**
     * Get application directory path.
     *
     * @method getAppPath
     * @return {String} app directory path
     */
    getAppPath: function () {
      var appPath = files.findAppDir();
      if (appPath) {
        appPath = files.pathResolve(appPath);
      }

      return files.convertToOSPath(appPath);
    },


    /**
     * Get path to application&#x27;s or application package&#x27;s &#x27;tests&#x27; directory
     *
     * @method getTestsPath
     * @param {String} packageName optional package name
     * @return {String} application&#x27;s tests directory
     */
    getTestsPath: function (packageName) {
      return files.convertToOSPath(
        files.pathJoin(packageName ? Velocity.getPackagePath(packageName) : Velocity.getAppPath(), &#x27;tests&#x27;)
      );
    },

    /**
     * Get path to application&#x27;s &#x27;packages&#x27; directory
     *
     * @method getPackagesPath
     * @return {String} application&#x27;s packages directory
     */
    getPackagesPath: function () {
      return files.convertToOSPath(files.pathJoin(Velocity.getAppPath(), &#x27;packages&#x27;));
    },

    /**
     * Get path to application&#x27;s package directory
     *
     * @method getPackagesPath
     * @param {String} packageName package name
     * @return {String} application&#x27;s packages directory
     */
    getPackagePath: function (packageName) {
      return files.convertToOSPath(files.pathJoin(Velocity.getPackagesPath(), packageName));
    },


    /**
     * A collection of callbacks to be executed after all tests have completed
     * and the aggregate test results have been reported.
     *
     * See {{#crossLink &quot;Velocity/addPostProcessor:method&quot;}}{{/crossLink}}
     *
     * @property postProcessors
     * @type Array
     * @default []
     */
    postProcessors: [],

    /**
     * Add a callback which will execute after all tests have completed
     * and after the aggregate test results have been reported.
     *
     * @method addPostProcessor
     * @param {Function} processor
     */
    addPostProcessor: function (processor) {
      Velocity.postProcessors.push(processor);
    },

    /**
     * Get a message that displays where bugs in Velocity core itself should
     * be reported.
     *
     * @method getReportGithubIssueMessage
     * @return {String} message with bug repo url
     */
    getReportGithubIssueMessage: function () {
      return &#x27;Please report the issue here: &#x27; +
        &#x27;https://github.com/meteor-velocity/velocity/issues&#x27;;
    },

    /**
     * Registers a testing framework plugin.
     *
     * @method registerTestingFramework
     * @param {String} name The name of the testing framework.
     * @param {Object} [options] Options for the testing framework.
     *   @param {String} [options.regex] The regular expression for test files
     *                    that should be assigned to the testing framework.
     *                    The path relative to the tests folder is matched
     *                    against it. Default: &quot;name/.+\.js$&quot; (name is
     *                    the testing framework name).
     *   @param {String} [options.disableAutoReset]   Velocity&#x27;s reset cycle
     *                    will skip reports and logs for this framework.
     *                    It is up to the framework to clean up its ****!
     *   @param {Function} [options.sampleTestGenerator] sampleTestGenerator
     *                    returns an array of fileObjects with the following
     *                    fields:
     *                      path - String - relative path to place test files
     *                                      (from PROJECT/tests)
     *                      contents - String - contents to put in the test file
     *                                          at the corresponding path
     */
    registerTestingFramework: function (name, options) {
      DEBUG &amp;&amp; console.log(&#x27;[velocity] Register framework &#x27; + name + &#x27; with regex &#x27; + options.regex);
      _config[name] = _parseTestingFrameworkOptions(name, options);
      // make sure the appropriate aggregate records are added
      VelocityAggregateReports.insert({
        name: name,
        result: &#x27;pending&#x27;
      });
    }

  });


//////////////////////////////////////////////////////////////////////
// Meteor Methods
//

  /**
   * Most communication with Velocity core is done via the following
   * Meteor methods.
   *
   * @class Meteor.methods
   */
  Meteor.methods({

    /**
     * Registers a testing framework plugin via a Meteor method.
     *
     * @method velocity/register/framework 
     * @param {String} name The name of the testing framework.
     * @param {Object} [options] Options for the testing framework.
     *   @param {String} [options.regex] The regular expression for test files
     *                    that should be assigned to the testing framework.
     *                    The path relative to the tests folder is matched
     *                    against it. Default: &quot;name/.+\.js$&quot; (name is
     *                    the testing framework name).
     *   @param {String} [options.disableAutoReset]   Velocity&#x27;s reset cycle
     *                    will skip reports and logs for this framework.
     *                    It is up to the framework to clean up its ****!
     *   @param {Function} [options.sampleTestGenerator] sampleTestGenerator
     *                    returns an array of fileObjects with the following
     *                    fields:
     *                      path - String - relative path to place test files
     *                                      (from PROJECT/tests)
     *                      contents - String - contents to put in the test file
     *                                          at the corresponding path
     */
    &#x27;velocity/register/framework&#x27;: function (name, options) {
      options = options || {};
      check(name, Match.Optional(String));
      check(options, {
        disableAutoReset: Match.Optional(Boolean),
        regex: Match.Optional(RegExp),
        sampleTestGenerator: Match.Optional(Function)
      });

      _config[name] = _parseTestingFrameworkOptions(name, options);

      // make sure the appropriate aggregate records are added
      _reset(_config);
    },


    /**
     * Re-init file watcher and clear all test results.
     *
     * @method velocity/reset
     */
    &#x27;velocity/reset&#x27;: function () {
      _reset(_config);
    },

    /**
     * Clear all test results.
     *
     * @method velocity/reports/reset
     * @param {Object} [options]
     *   @param {String} [options.framework] The name of a specific framework
     *                    to clear results for.  Ex. &#x27;jasmine&#x27; or &#x27;mocha&#x27;
     *   @param {Array} [options.notIn] A list of test Ids which should be kept
     *                                  (not cleared).  These Ids must match the
     *                                  ones passed to &#x60;velocity/reports/submit&#x60;.
     */
    &#x27;velocity/reports/reset&#x27;: function (options) {
      options = options || {};
      check(options, {
        framework: Match.Optional(String),
        notIn: Match.Optional([String])
      });

      var query = {};
      if (options.framework) {
        query.framework = options.framework;
        VelocityAggregateReports.upsert({name: options.framework}, {$set: {result: &#x27;pending&#x27;}});
      }
      if (options.notIn) {
        query = _.assign(query, {_id: {$nin: options.notIn}});
      }
      VelocityTestReports.remove(query);

      _updateAggregateReports();
    },


    /**
     * Clear all log entries.
     *
     * @method velocity/logs/reset
     * @param {Object} [options]
     *   @param {String} [options.framework] The name of a specific framework
     *                                       to clear logs for.
     */
    &#x27;velocity/logs/reset&#x27;: function (options) {
      options = options || {};
      check(options, {
        framework: Match.Optional(String)
      });

      var query = {};
      if (options.framework) {
        query.framework = options.framework;
      }
      VelocityLogs.remove(query);
    },


    /**
     * Log a message to the Velocity log store.  This provides a central
     * location for different reporters to query for test framework log
     * entries.
     *
     * @method velocity/logs/submit
     * @param {Object} options
     *   @param {String} options.framework The name of the test framework
     *   @param {String} options.message The message to log
     *   @param {String} [options.level] Log level.  Ex. &#x27;error&#x27;. Default: &#x27;info&#x27;
     *   @param {Date} [options.timestamp]
     */
    &#x27;velocity/logs/submit&#x27;: function (options) {
      check(options, {
        framework: String,
        message: String,
        level: Match.Optional(String),
        timestamp: Match.Optional(Match.OneOf(Date, String))
      });

      VelocityLogs.insert({
        timestamp: options.timestamp ? new Date(options.timestamp) : new Date(),
        level: options.level || &#x27;info&#x27;,
        message: options.message,
        framework: options.framework
      });
    },


    /**
     * Record the results of an individual test run; a simple collector of
     * test data.
     *
     * The &#x60;data&#x60; object is stored in its entirety; any field may be passed in.
     * The optional fields documented here are suggestions based on what the
     * standard html-reporter supports.  Whether or not a field is actually
     * used is up to the specific test reporter that the user has installed.
     *
     * @method velocity/reports/submit
     * @param {Object} data
     *   @param {String} data.name Name of the test that was executed.
     *   @param {String} data.framework Name of a testing framework.
     *                                  For example, &#x27;jasmine&#x27; or &#x27;mocha&#x27;.
     *   @param {String} data.result The results of the test.  Standard values
     *                               are &#x27;passed&#x27; and &#x27;failed&#x27;.  Different test
     *                               reporters can support other values.  For
     *                               example, the aggregate tests collection uses
     *                               &#x27;pending&#x27; to indicate that results are still
     *                               coming in.
     *   @param {String} [data.id] Used to update a specific test result.  If not
     *                             provided, frameworks can use the
     *                             &#x60;velocity/reports/reset&#x60; Meteor method to
     *                             clear all tests.
     *   @param {Array} [data.ancestors] The hierarchy of suites and blocks above
     *                                   this test. For example,
     *                                [&#x27;Template&#x27;, &#x27;leaderboard&#x27;, &#x27;selected_name&#x27;]
     *   @param {Date} [data.timestamp] The time that the test started for this
     *                                  result.
     *   @param {Number} [data.duration] The test duration in milliseconds.
     *   @param {String} [data.browser] Which browser did the test run in?
     *   @param {String} [data.failureType] For example, &#x27;expect&#x27; or &#x27;assert&#x27;
     *   @param {String} [data.failureMessage]
     *   @param {String} [data.failureStackTrace] The stack trace associated with
     *                                            the failure
     */
    &#x27;velocity/reports/submit&#x27;: function (data) {
      check(data, Match.ObjectIncluding({
        name: String,
        framework: String,
        result: String,
        id: Match.Optional(String),
        ancestors: Match.Optional([String]),
        timestamp: Match.Optional(Match.OneOf(Date, String)),
        duration: Match.Optional(Number),
        browser: Match.Optional(String),
        failureType: Match.Optional(Match.Any),
        failureMessage: Match.Optional(String),
        failureStackTrace: Match.Optional(Match.Any)
      }));

      data.timestamp = data.timestamp ? new Date(data.timestamp) : new Date();
      data.id = data.id || Random.id();

      VelocityTestReports.upsert(data.id, {$set: data});

      _updateAggregateReports();
    },  // end postResult


    /**
     * Frameworks must call this method to inform Velocity they have completed
     * their current test runs. Velocity uses this flag when running in CI mode.
     *
     * @method velocity/reports/completed
     * @param {Object} data
     *   @param {String} data.framework Name of a test framework.  Ex. &#x27;jasmine&#x27;
     */
    &#x27;velocity/reports/completed&#x27;: function (data) {
      check(data, {
        framework: String
      });

      VelocityAggregateReports.upsert({&#x27;name&#x27;: data.framework},
        {$set: {&#x27;result&#x27;: &#x27;completed&#x27;}});
      _updateAggregateReports();
    },  // end completed


    /**
     * Copy sample tests from frameworks &#x60;sample-tests&#x60; directories
     * to the user&#x27;s application&#x27;s &#x60;tests&#x60; directory.
     *
     * @method velocity/copySampleTests
     *
     * @param {Object} options
     *   @param {String} options.framework Framework name. Ex. &#x27;jasmine&#x27;, &#x27;mocha&#x27;
     */
    &#x27;velocity/copySampleTests&#x27;: function (options) {
      options = options || {};
      check(options, {
        framework: String
      });

      var sampleTestGenerator = _config[options.framework].sampleTestGenerator;
      if (sampleTestGenerator) {
        var sampleTests = sampleTestGenerator(options);

        DEBUG &amp;&amp; console.log(&#x27;[velocity] found &#x27;, sampleTests.length,
          &#x27;sample test files for&#x27;, options.framework);

        sampleTests.forEach(function (testFile) {
          var fullTestPath = files.pathJoin(Velocity.getTestsPath(), testFile.path);
          var testDir = files.pathDirname(fullTestPath);
          mkdirp(files.convertToOSPath(testDir));
          files.writeFile(fullTestPath, testFile.contents);
        });
      }
    }  // end copySampleTests



  });  // end Meteor methods




//////////////////////////////////////////////////////////////////////
// Private functions
//

  function _triggerVelocityStartupFunctions () {
    _velocityStarted = true;
    DEBUG &amp;&amp; console.log(&#x27;[velocity] Triggering queued startup functions&#x27;);
    var func;
    while (func = _velocityStartupFunctions.pop()) {
      func();
    }
  }

  function _parseTestingFrameworkOptions (name, options) {
    options = options || {};
    _.defaults(options, {
      name: name,
      regex: name + &#x27;/.+\\.js$&#x27;
    });

    options._regexp = new RegExp(options.regex);

    return options;
  }


  // Runs each test framework once when in continous integration mode.
  function _launchContinuousIntegration () {

    if (CONTINUOUS_INTEGRATION) {
      _.forEach(_getTestFrameworkNames(), function (testFramework) {
        Meteor.call(&#x27;velocity/logs/reset&#x27;, {framework: testFramework}, function () {

          Meteor.call(testFramework + &#x27;/reset&#x27;, function (error) {
            if (error) {
              console.error(&#x27;[velocity] ERROR; testFramework/rest not implemented&#x27;, error);
            }
          });
          Meteor.call(testFramework + &#x27;/run&#x27;, function (error) {
            if (error) {
              console.error(&#x27;[velocity] ERROR; testFramework/run not implemented&#x27;, error);
            }
          });
        });
      });
    }
  }

  /**
   * Initialize the directory/file watcher.
   *
   * @method _initFileWatcher
   * @param {Object} config See {{#crossLink &quot;Velocity/registerTestingFramework:method&quot;}}{{/crossLink}}
   * @param {function} callback  Called after the watcher completes its first scan and is ready
   * @private
   */
  function _initFileWatcher (config, callback) {

    VelocityTestFiles.remove({});
    VelocityFixtureFiles.remove({});

    var paths = [Velocity.getTestsPath()];

    var packagesPath = Velocity.getPackagesPath();
    if (VelocityInternals.isDirectory(packagesPath)) {
      var packageNames = files.readdir(packagesPath);
      var packageTestsPaths = _.chain(packageNames)
        .filter(_isPackageWithTests)
        .map(Velocity.getTestsPath)
        .value();
      paths.push.apply(paths, packageTestsPaths);
    }

    paths = _.map(paths, files.convertToOSPath);

    DEBUG &amp;&amp; console.log(&#x27;[velocity] Add paths to watcher&#x27;, paths);

    _watcher = chokidar.watch(paths, {ignored: /[\/\\]\./, persistent: true});
    _watcher.on(&#x27;add&#x27;, Meteor.bindEnvironment(function (filePath) {

      var relativePath,
          targetFramework,
          data;

      filePath = files.convertToStandardPath(files.pathNormalize(filePath));
      relativePath = _getRelativePath(filePath);

      // if this is a fixture file, put it in the fixtures collection
      if (FIXTURE_REG_EXP.test(relativePath)) {
        DEBUG &amp;&amp; console.log(&#x27;[velocity] Found fixture file&#x27;, relativePath);
        VelocityFixtureFiles.insert({
          _id: filePath,
          absolutePath: filePath,
          relativePath: relativePath,
          lastModified: Date.now()
        });
        // bail early
        return;
      }

      DEBUG &amp;&amp; console.log(&#x27;[velocity] Search framework for path&#x27;, relativePath);

      var packageRelativePath = (relativePath.indexOf(&#x27;packages&#x27;) === 0) ?
        relativePath.split(&#x27;/&#x27;).slice(2).join(&#x27;/&#x27;) :
        relativePath;
      // test against each test framework&#x27;s regexp matcher, use first one that matches
      targetFramework = _.find(config, function (framework) {
        return framework._regexp.test(packageRelativePath);
      });

      if (targetFramework) {
        DEBUG &amp;&amp; console.log(&#x27;[velocity] Target framework for&#x27;, relativePath, &#x27;is&#x27;, targetFramework.name);

        data = {
          _id: filePath,
          name: files.pathBasename(filePath),
          absolutePath: filePath,
          relativePath: relativePath,
          targetFramework: targetFramework.name,
          lastModified: Date.now()
        };

        VelocityTestFiles.insert(data);
      } else {
        DEBUG &amp;&amp; console.log(&#x27;[velocity] No framework registered for&#x27;, relativePath);
      }
    }));  // end watcher.on &#x27;add&#x27;

    _watcher.on(&#x27;change&#x27;, Meteor.bindEnvironment(function (filePath) {
      DEBUG &amp;&amp; console.log(&#x27;[velocity] File changed:&#x27;, _getRelativePath(filePath));

      // Since we key on filePath and we only add files we&#x27;re interested in,
      // we don&#x27;t have to worry about inadvertently updating records for files
      // we don&#x27;t care about.
      VelocityTestFiles.update(filePath, {$set: {lastModified: Date.now()}});
    }));

    _watcher.on(&#x27;unlink&#x27;, Meteor.bindEnvironment(function (filePath) {
      DEBUG &amp;&amp; console.log(&#x27;[velocity] File removed:&#x27;, _getRelativePath(filePath));
      VelocityTestFiles.remove(filePath);
    }));

    _watcher.on(&#x27;ready&#x27;, Meteor.bindEnvironment(function () {
      DEBUG &amp;&amp; console.log(&#x27;[velocity] File scan complete, now watching&#x27;, Velocity.getTestsPath().substring(Velocity.getAppPath().length));
      if (callback) {
        callback();
      }
    }));

  }  // end _initFileWatcher

  function _isPackageWithTests(packageName) {
    return packageName !== &#x27;tests-proxy&#x27; &amp;&amp;
      VelocityInternals.isDirectory(Velocity.getTestsPath(packageName));
  }

  /**
   * Re-init file watcher and clear all test results.
   *
   * @method _reset
   * @param {Object} config See {{#crossLink &quot;Velocity/registerTestingFramework:method&quot;}}{{/crossLink}}
   * @private
   */
  function _reset (config) {

    DEBUG &amp;&amp; console.log(&#x27;[velocity] resetting the world&#x27;);

    var frameworksWithDisableAutoReset = _(config).where({disableAutoReset: true}).pluck(&#x27;name&#x27;).value();
    DEBUG &amp;&amp; console.log(&#x27;[velocity] frameworks with disable auto reset:&#x27;, frameworksWithDisableAutoReset);
    VelocityTestReports.remove({framework: {$nin: frameworksWithDisableAutoReset}});
    VelocityLogs.remove({framework: {$nin: frameworksWithDisableAutoReset}});
    VelocityAggregateReports.remove({});
    _.forEach(_getTestFrameworkNames(), function (testFramework) {
      VelocityAggregateReports.insert({
        name: testFramework,
        result: &#x27;pending&#x27;
      });
    });

  }

  /**
   * If any one test has failed, mark the aggregate test result as failed.
   *
   * @method _updateAggregateReports
   * @private
   */
  function _updateAggregateReports () {

    VelocityAggregateReports.upsert({name: &#x27;aggregateResult&#x27;}, {$set: {result: &#x27;pending&#x27;}});
    VelocityAggregateReports.upsert({name: &#x27;aggregateComplete&#x27;}, {$set: {result: &#x27;pending&#x27;}});

    // if all of our test reports have valid results
    if (!VelocityTestReports.findOne({result: &#x27;&#x27;})) {

      // pessimistically set passed state, ensuring all other states take precedence in order below
      var aggregateResult =
            VelocityTestReports.findOne({result: &#x27;failed&#x27;}) ||
            VelocityTestReports.findOne({result: &#x27;undefined&#x27;}) ||
            VelocityTestReports.findOne({result: &#x27;skipped&#x27;}) ||
            VelocityTestReports.findOne({result: &#x27;pending&#x27;}) ||
            VelocityTestReports.findOne({result: &#x27;passed&#x27;}) ||
            {result: &#x27;pending&#x27;};

      // update the global status
      VelocityAggregateReports.update({&#x27;name&#x27;: &#x27;aggregateResult&#x27;}, {$set: {result: aggregateResult.result}});
    }

    // if all test frameworks have completed, upsert an aggregate completed record
    var completedFrameworksCount = VelocityAggregateReports.find({
      &#x27;name&#x27;: {$in: _getTestFrameworkNames()},
      &#x27;result&#x27;: &#x27;completed&#x27;
    }).count();

    var aggregateComplete = VelocityAggregateReports.findOne({&#x27;name&#x27;: &#x27;aggregateComplete&#x27;});
    if (aggregateComplete) {
      if ((aggregateComplete.result !== &#x27;completed&#x27;) &amp;&amp; (_getTestFrameworkNames().length === completedFrameworksCount)) {
        VelocityAggregateReports.update({&#x27;name&#x27;: &#x27;aggregateComplete&#x27;}, {$set: {&#x27;result&#x27;: &#x27;completed&#x27;}});
        _.each(Velocity.postProcessors, function (processor) {
          processor();
        });
      }
    }
  }

  function _getRelativePath (filePath) {
    var relativePath = filePath.substring(Velocity.getAppPath().length);
    if (relativePath[0] === &#x27;/&#x27;) {
      relativePath = relativePath.substring(1);
    }
    return relativePath;
  }

  function _getTestFrameworkNames () {
    return _.pluck(_config, &#x27;name&#x27;);
  }

})();

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
